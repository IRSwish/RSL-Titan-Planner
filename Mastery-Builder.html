<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RSL Tools | Mastery Builder</title>
  <link rel="stylesheet" href="style/style.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">

  <style>
  /* === Layout === */
  #builder {
    display: flex;
    justify-content: center;
    gap: 40px;
    flex-wrap: wrap;
    margin: 40px auto;
    max-width: 1400px;
  }

  .scroll-counter {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 40px;
    margin-top: 20px;
  }

  .scroll-type {
    display: flex;
    align-items: center;
    gap: 8px;
    font-family: 'Inter', sans-serif;
    font-size: 18px;
    color: var(--text-color);
  }

  .scroll-type img {
    width: 36px;
    height: 36px;
  }

  .tree {
    background: var(--event-bg);
    border: 2px solid var(--event-border);
    border-radius: 12px;
    padding: 20px;
    width: 360px;
    text-align: center;
    box-shadow: 0 0 10px rgba(212,175,55,0.2);
    position: relative;
  }

  .tree h2 {
    font-family: 'American Captain';
    color: var(--line-color);
    font-size: 24px;
    margin-bottom: 10px;
  }

  .reset-tree {
    position: absolute;
    top: 10px;
    left: 10px;
    background: linear-gradient(145deg, #1a1a1a, #2b2b2b);
    border: 2px solid var(--event-border);
    color: var(--text-color);
    font-weight: 600;
    font-size: 13px;
    padding: 4px 10px;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .reset-tree:hover {
    transform: scale(1.05);
    box-shadow: 0 0 8px var(--event-border);
  }

  .row {
    display: flex;
    justify-content: space-between;
    gap: 20px;
    margin: 25px 0;
    position: relative;
  }

  .row.centered {
    justify-content: center;
  }

  .mastery {
    width: 70px;
    height: 70px;
    background: #1a1a1a;
    border: 2px solid #555;
    clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
    z-index: 2;
    opacity: 1;
  }

  .mastery:hover {
    box-shadow: 0 0 10px rgba(212,175,55,0.3);
  }

  .mastery.active {
    border-color: var(--line-color);
    box-shadow: 0 0 12px var(--line-color);
    background-color: rgba(212,175,55,0.1);
  }

  .mastery.locked {
    opacity: 0.3;
    cursor: not-allowed;
  }

    /* états visuels supplémentaires */
    .mastery.available:not(.active):not(.locked) {
    border-color: var(--line-color);
    box-shadow: 0 0 10px rgba(212,175,55,0.35);
    animation: pulse-available 1.4s ease-in-out infinite;
    }
    @keyframes pulse-available {
    0% { box-shadow: 0 0 6px rgba(212,175,55,0.2); }
    50%{ box-shadow: 0 0 14px rgba(212,175,55,0.55); }
    100%{ box-shadow: 0 0 6px rgba(212,175,55,0.2); }
    }

  /* Connection lines */
  .connection {
    position: absolute;
    width: 4px;
    height: 40px;
    left: 50%;
    top: 70px;
    transform: translateX(-50%);
    background: rgba(212,175,55,0.15);
    z-index: 1;
    opacity: 0;
    transition: opacity 0.2s ease, box-shadow 0.3s ease;
  }

  .connection.active {
    opacity: 1;
    background: linear-gradient(to bottom, #d4af37, #fce39b);
    box-shadow: 0 0 10px #d4af37;
  }

  </style>
</head>
<body>
  <div id="menu-container"></div>

  <div class="header-wrapper">
    <header id="page-title">Mastery Builder</header>
  </div>

  <div class="scroll-counter">
    <div class="scroll-type" id="basic-scrolls">
      <img src="style/img/Misc/Scroll-Basic.webp" alt="Basic Scrolls">
      <span>0 / 100</span>
    </div>
    <div class="scroll-type" id="advanced-scrolls">
      <img src="style/img/Misc/Scroll-Advanced.webp" alt="Advanced Scrolls">
      <span>0 / 600</span>
    </div>
    <div class="scroll-type" id="divine-scrolls">
      <img src="style/img/Misc/Scroll-Divine.webp" alt="Divine Scrolls">
      <span>0 / 950</span>
    </div>
  </div>

  <div id="builder">
    <div class="tree" data-branch="offense">
      <button class="reset-tree">Reset</button>
      <h2>Offense</h2>
      <div class="rows"></div>
    </div>

    <div class="tree" data-branch="defense">
      <button class="reset-tree">Reset</button>
      <h2>Defense</h2>
      <div class="rows"></div>
    </div>

    <div class="tree" data-branch="support">
      <button class="reset-tree">Reset</button>
      <h2>Support</h2>
      <div class="rows"></div>
    </div>
  </div>

<script>
(() => {
  // ---------- CONFIG ----------
  const TIER_COUNTS = [2,4,4,4,4,4];           
  const TIER_COST   = {1:5, 2:5, 3:30, 4:30, 5:200, 6:350};
  const ABS_COLS = tier => (tier === 1 ? [2,3] : [1,2,3,4]); // colonnes absolues (T1 = 2 & 3)

  // ---------- BUILD ----------
  const trees = document.querySelectorAll('.tree');
  trees.forEach(tree => {
    if (tree.dataset._built) return;
    tree.dataset._built = '1';
    const branch = tree.dataset.branch;
    const rows = tree.querySelector('.rows') || (() => {
      const d = document.createElement('div'); d.className = 'rows'; tree.appendChild(d); return d;
    })();

    for (let tier=1; tier<=6; tier++) {
      const row = document.createElement('div');
      row.className = 'row' + (tier===1 ? ' centered' : '');
      rows.appendChild(row);

      ABS_COLS(tier).forEach(colAbs => {
        const m = document.createElement('div');
        m.className = 'mastery';
        m.dataset.id   = `${branch}-${tier}-${colAbs}`;
        m.dataset.tier = String(tier);
        m.dataset.col  = String(colAbs);

        // connexion visuelle verticale si même colonne existe au tier suivant
        if (tier < 6 && ABS_COLS(tier+1).includes(colAbs)) {
          const conn = document.createElement('div');
          conn.className = 'connection';
          conn.dataset.from = `${branch}-${tier}-${colAbs}`;
          conn.dataset.to   = `${branch}-${tier+1}-${colAbs}`;
          m.appendChild(conn);
        }
        row.appendChild(m);
      });
    }

    const btn = tree.querySelector('.reset-tree');
    if (btn) btn.addEventListener('click', () => {
      tree.querySelectorAll('.mastery.active').forEach(x => x.classList.remove('active'));
      updateAll(true);
    });
  });

  const masteries = Array.from(document.querySelectorAll('.mastery'));

  // ---------- EVENTS ----------
  masteries.forEach(m => {
    m.addEventListener('click', () => {
      if (m.classList.contains('locked')) return;

      if (m.classList.contains('active')) {
        m.classList.remove('active');
        updateAll(true); // true = autorise la dépropagation
        return;
      }
      if (!canSelect(m)) return;
      m.classList.add('active');
      updateAll(true);
    });
  });

  // ---------- STATE ----------
  function getState() {
    const activeEls = Array.from(document.querySelectorAll('.mastery.active'));
    const active = new Set(activeEls.map(x => x.dataset.id));
    const byBranch = {offense:[], defense:[], support:[]};
    activeEls.forEach(el => byBranch[el.dataset.id.split('-')[0]].push(el));

    const activeTrees = new Set();
    const perTierGlobal = {1:0,2:0,3:0,4:0,5:0,6:0};
    const perTierPerBranch = { offense:{1:0,2:0,3:0,4:0,5:0,6:0},
                               defense:{1:0,2:0,3:0,4:0,5:0,6:0},
                               support:{1:0,2:0,3:0,4:0,5:0,6:0} };
    let totalT6 = 0;

    active.forEach(id => {
      const [b, tStr] = id.split('-');
      const t = +tStr;
      activeTrees.add(b);
      perTierGlobal[t] += 1;
      perTierPerBranch[b][t] += 1;
      if (t === 6) totalT6++;
    });

    return { active, byBranch, activeTrees, perTierGlobal, perTierPerBranch, totalT6 };
  }

  // ---------- ADJACENCY ----------
  // autorisations d'ouverture : vertical/diagonale (tier+1) + horizontale (même tier ±1 si une active adjacente existe)
  function isAdjacentAllowed(m) {
    const [branch, tStr, cStr] = m.dataset.id.split('-');
    const tier = +tStr, col = +cStr;
    if (tier === 1) return true;

    // depuis T-1 : vertical / diagonales
    const prevTier = tier - 1;
    for (const d of [-1,0,1]) {
      const prev = document.querySelector(`[data-id="${branch}-${prevTier}-${col+d}"]`);
      if (prev && prev.classList.contains('active')) return true;
    }

    // horizontale au même tier (adjacente ±1) si au moins une active à ce tier
    const anyActiveThisTier = !!document.querySelector(`.mastery.active[data-id^="${branch}-${tier}-"]`);
    if (anyActiveThisTier) {
      for (const d of [-1,1]) {
        const adj = document.querySelector(`[data-id="${branch}-${tier}-${col+d}"]`);
        if (adj && adj.classList.contains('active')) return true;
      }
    }
    return false;
  }

  // voisinage pour la connectivité (graph des actives) — même règles que ci-dessus mais **entre actives**
  function activeNeighbors(el, activeSet) {
    const [branch, tStr, cStr] = el.dataset.id.split('-');
    const tier = +tStr, col = +cStr;
    const res = [];

    // liens horizontaux (même tier ±1)
    for (const d of [-1,1]) {
      const adj = document.querySelector(`[data-id="${branch}-${tier}-${col+d}"]`);
      if (adj && activeSet.has(adj.dataset.id)) res.push(adj);
    }
    // liens vers tier-1 (vertical/diagonales)
    if (tier > 1) {
      const prevTier = tier - 1;
      for (const d of [-1,0,1]) {
        const prev = document.querySelector(`[data-id="${branch}-${prevTier}-${col+d}"]`);
        if (prev && activeSet.has(prev.dataset.id)) res.push(prev);
      }
    }
    // liens vers tier+1 (vertical/diagonales)
    if (tier < 6) {
      const nextTier = tier + 1;
      for (const d of [-1,0,1]) {
        const nxt = document.querySelector(`[data-id="${branch}-${nextTier}-${col+d}"]`);
        if (nxt && activeSet.has(nxt.dataset.id)) res.push(nxt);
      }
    }
    return res;
  }

  // ---------- RULES ----------
  function canSelect(m) {
    const { activeTrees, perTierGlobal, perTierPerBranch, totalT6 } = getState();
    const [branch, tStr] = m.dataset.id.split('-');
    const tier = +tStr;

    // 2 arbres max
    if (!activeTrees.has(branch) && activeTrees.size >= 2) return false;

    // adjacency
    if (!isAdjacentAllowed(m)) return false;

    // quotas par tier
    if (tier === 1) {
      if (perTierPerBranch[branch][1] >= 1) return false;
      return true;
    }
    if (tier >= 2 && tier <= 5) {
      if (perTierGlobal[tier] >= 3) return false;
      if (perTierPerBranch[branch][tier] >= 2) return false;
      return true;
    }
    if (tier === 6) {
      if (totalT6 >= 1) return false;
      return true;
    }
    return true;
  }

  // ---------- VALIDATION & CASCADE ----------
  function validateActiveConnections() {
    const { active, byBranch } = getState();
    let removedAny = false;

    // pour chaque arbre, s'assurer que toutes les actives sont connectées à sa T1 via le graphe d'adjacence
    ['offense','defense','support'].forEach(branch => {
      const actives = byBranch[branch];
      if (!actives || actives.length === 0) return;

      // trouver la T1 active (ancre); s'il n'y en a pas -> tout doit sauter
      const anchor = actives.find(el => +el.dataset.tier === 1);
      if (!anchor) {
        actives.forEach(el => { el.classList.remove('active'); removedAny = true; });
        return;
      }

      const activeSet = new Set(actives.map(el => el.dataset.id));
      // BFS/DFS depuis l’ancre
      const stack = [anchor];
      const visited = new Set([anchor.dataset.id]);

      while (stack.length) {
        const cur = stack.pop();
        activeNeighbors(cur, activeSet).forEach(n => {
          if (!visited.has(n.dataset.id)) {
            visited.add(n.dataset.id);
            stack.push(n);
          }
        });
      }

      // toutes les actives non visitées = déconnectées -> on retire
      actives.forEach(el => {
        if (!visited.has(el.dataset.id)) {
          el.classList.remove('active');
          removedAny = true;
        }
      });
    });

    return removedAny;
  }

  // ---------- VISU & COUNTS ----------
  function updateConnections() {
    document.querySelectorAll('.connection').forEach(c => {
      const from = document.querySelector(`[data-id="${c.dataset.from}"]`);
      const to   = document.querySelector(`[data-id="${c.dataset.to}"]`);
      c.classList.toggle('active', !!(from && to && from.classList.contains('active') && to.classList.contains('active')));
    });
  }

  function updateLocksAndAvailable() {
    const { activeTrees } = getState();
    masteries.forEach(m => {
      if (m.classList.contains('active')) {
        m.classList.remove('locked','available');
        return;
      }
      const branch = m.dataset.id.split('-')[0];
      let lock = false;
      if (!activeTrees.has(branch) && activeTrees.size >= 2) lock = true;

      const selectable = !lock && canSelect(m);
      m.classList.toggle('locked', !selectable);
      m.classList.toggle('available', selectable);
    });
  }

  function updateScrolls() {
    let basic=0, adv=0, div=0;
    document.querySelectorAll('.mastery.active').forEach(m => {
      const tier = +m.dataset.tier;
      const cost = TIER_COST[tier] || 0;
      if (tier<=2) basic += cost;
      else if (tier<=4) adv += cost;
      else div += cost;
    });
    const basicEl = document.querySelector('#basic-scrolls span');
    const advEl   = document.querySelector('#advanced-scrolls span');
    const divEl   = document.querySelector('#divine-scrolls span');
    if (basicEl) basicEl.textContent = `${Math.min(basic,100)} / 100`;
    if (advEl)   advEl.textContent   = `${Math.min(adv,600)} / 600`;
    if (divEl)   divEl.textContent   = `${Math.min(div,950)} / 950`;
  }

  function updateAll(doCascade=false) {
    // 1) une première passe visuelle
    updateConnections();
    updateLocksAndAvailable();
    updateScrolls();

    // 2) dépropagation et seconde passe si on a retiré des nodes
    if (doCascade) {
      const removed = validateActiveConnections();
      if (removed) {
        updateConnections();
        updateLocksAndAvailable();
        updateScrolls();
      }
    }
  }

  // ---------- INITIAL ----------
  const params = new URLSearchParams(location.search);
  if (params.has('m')) {
    const ids = atob(params.get('m')).split(',').filter(Boolean);
    ids.forEach(id => document.querySelector(`[data-id="${id}"]`)?.classList.add('active'));
  }
  updateAll(true);
})();
</script>

</body>
</html>
